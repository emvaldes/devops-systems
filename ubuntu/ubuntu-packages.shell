#!/usr/bin/env bash

## Objective:
## This first-release is to test the script's capabilities to identify if a
## package is installed or not. All these packages were manually installed.
## After this initial test, the target Virtual Machine will be reset to its
## baseline and the script will start installing all these packages.

## Notes: These are target (pending) tools with custom installations
## [configuration]:   ansible, pulumi
## [programming];     go
## [cloud tools]:     aws-iam-authenticator, awscli, saml2aws
## [hashicorp]:       boundary, consul, nomad, packer, terraform, vagrant, vault, waypoint

declare -a awscloud=(
    awscli
    aws-iam-authenticator
    saml2aws
  );

declare -a hashicorp=(
    boundary
    consul
    nomad
    packer
    terraform
    vagrant
    vault
    waypoint
  );

## Inpsecting these already installed devnetops tools
declare -a installing=(
    snap:atom
    snap:pycharm-community
    snap:postman
    snap:powershell
    apt:ansible
    apt:apt-file
    apt:aptitude
    apt:arp-scan
    apt:autoconf
    apt:bat
    apt:bmon
    apt:build-essential
    apt:bwctl-client
    apt:bwctl-server
    apt:cloc
    apt:code
    apt:coreutils
    apt:curl
    apt:dos2unix
    apt:ethtool
    apt:fping
    apt:gh
    apt:git
    apt:gnupg
    apt:golang
    apt:grepcidr
    apt:hping3
    apt:htop
    apt:htop
    apt:ifstat
    apt:iftop
    apt:ipcalc
    apt:iperf3
    apt:iproute2
    apt:iptraf-ng
    apt:jq
    apt:libssl-dev
    apt:lynx
    apt:mc
    apt:mtr
    apt:netcat
    apt:net-tools
    apt:ngrep
    apt:nikto
    apt:nodejs
    apt:nload
    apt:nmap
    apt:npm
    apt:openssh-server
    apt:parallel
    apt:pgpdump
    apt:procps
    apt:psmisc
    apt:python3-venv
    apt:screen
    apt:sipcalc
    apt:socat
    apt:speedometer
    apt:speedtest-cli
    apt:stress
    apt:sysvinit-utils
    apt:telnet
    apt:tftpd-hpa
    apt:tree
    apt:unzip
    apt:vim
    apt:virtualenv
    apt:wget
    apt:wireshark
    apt:zenity
    apt:zip
  );

## Configuring Package Instation Reports path
installer="${HOME}/packages";
rm -rf ${installer} && mkdir -p ${installer};

## Identifying the installed-packages report file.
installed="${installer}/installed.list";
rm ${installed} 2>/dev/null;

## Identifying the installed-packages report file.
missing="${installer}/missing.list";
rm ${missing} 2>/dev/null;

## These are just iteration counters.
counter=1;
count_miss=1;
count_inst=1;

## Aggregating both target groups
declare -a packages=( ${installing[@]} );
for xitem in ${packages[@]}; do

  installer="${xitem%%\:*}";
  package="${xitem##*\:}";

  ## Identifying if package is already installed.
  apt list --installed | egrep -w "^${package}"; result=$?;

  ## Evaluating APT Installed output
  if [[ $result -ne 0 ]]; then
          ## Package is not installed.
          echo -e "\n\n-------------------------";
	        echo -e "Installing: ${result} = $(( counter++ )) -> $(( count_miss++ ))";
          echo -e "   Package: ${package}";
          echo -e "-------------------------\n";
          echo -e "Warning: ${package} package is not installed! ";
          echo -e "${package}" >> ${missing};

          ## Constructing package's folder (container)
          xpath="${installer}/missing/${package}";
          mkdir -p "${xpath}";

          ## Installing package via APT
          case "${installer}" in
             apt ) sudo apt  install ${package} --yes ;
            snap ) sudo snap install ${package} --yes ;
          esac;


    else  ## Inspecting installed package.
          echo -e "\n\n-------------------------";
          echo -e " Installed: ${result} = $(( counter++ )) -> $(( count_inst++ ))";
          echo -e "   Package: ${package}";
          echo -e "-------------------------\n";
      	  echo -e "${package}" >> ${installed};

          ## Constructing package's folder (container)
          xpath="${installer}/installed/${package}";
      	  mkdir -p "${xpath}";

          ## Upgrading package only if it's already installed.
          sudo apt-get --only-upgrade install ${package} --yes | tee "${xpath}/${package}.upgrade";

          ## Collecting Package Information.
      	  apropos --exact ${package} | tee "${xpath}/${package}.apropos";
      	  apt search ${package} | egrep "^${package}.*" | tee "${xpath}/${package}.search";
      	  apt list ${package} | egrep "^${package}.*" | tee "${xpath}/${package}.list";
      	  # apt depends ${package} | tee "${xpath}/${package}.depends";
      	  apt show ${package} | tee "${xpath}/${package}.show";

  fi;

done;
