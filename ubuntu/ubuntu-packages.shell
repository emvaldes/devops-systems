#!/usr/bin/env bash

## Objective:
## This first-release is to test the script's capabilities to identify if a
## package is installed or not. All these packages were manually installed.
## After this initial test, the target Virtual Machine will be reset to its
## baseline and the script will start installing all these packages.

## Notes: These are target (pending) tools with custom installations
## [configuration]:   pulumi
## [cloud tools]:     aws-iam-authenticator, awscli, saml2aws
## [hashicorp]:       boundary, consul, nomad, packer, terraform, vagrant, vault, waypoint

oIFS="${IFS}";
IFS=$'\n';

declare -a awscloud=(
    awscli
    aws-iam-authenticator
    saml2aws
  );

declare -a hashicorp=(
    boundary
    consul
    nomad
    packer
    terraform
    vagrant
    vault
    waypoint
  );

## Inpsecting these already installed devnetops tools
declare -a packages=(
    "snap --classic:atom"
    "snap --classic:pycharm-community"
    "snap:postman"
    "snap --classic:powershell"
    apt:ansible
    apt:apt-file
    apt:aptitude
    apt:arp-scan
    apt:autoconf
    apt:bat
    apt:bmon
    apt:build-essential
    apt:bwctl-client
    apt:bwctl-server
    apt:cloc
    apt:code
    apt:coreutils
    apt:curl
    apt:dos2unix
    apt:ethtool
    apt:fping
    apt:gh
    apt:git
    apt:gnupg
    apt:golang
    apt:grepcidr
    apt:hping3
    apt:htop
    apt:htop
    apt:ifstat
    apt:iftop
    apt:ipcalc
    apt:iperf3
    apt:iproute2
    apt:iptraf-ng
    apt:jq
    apt:libssl-dev
    apt:lynx
    apt:mc
    apt:mtr
    apt:netcat
    apt:net-tools
    apt:ngrep
    apt:nikto
    apt:nodejs
    apt:nload
    apt:nmap
    apt:npm
    apt:openssh-server
    apt:parallel
    apt:pgpdump
    apt:procps
    apt:psmisc
    apt:python3-venv
    apt:python-is-python3
    apt:screen
    apt:sipcalc
    apt:socat
    apt:speedometer
    apt:speedtest-cli
    apt:stress
    apt:sysvinit-utils
    apt:telnet
    apt:tftpd-hpa
    apt:tree
    apt:unzip
    apt:vim
    apt:virtualenv
    apt:wget
    apt:wireshark
    apt:zenity
    apt:zip
  );

## Configuring Package Instation Reports path
location="$(pwd)/packages";
rm -rf ${location} && mkdir -p ${location};

## Identifying the installed-packages report file.
installed="${location}/installed.list";
rm ${installed} 2>/dev/null;

## Identifying the installed-packages report file.
missing="${location}/missing.list";
rm ${missing} 2>/dev/null;

## These are just iteration counters.
counter=1;
count_miss=1;
count_inst=1;

for xitem in ${packages[@]}; do

  installer="${xitem%%\:*}";
  # echo -e "Installer: ${installer}";

  package="${xitem##*\:}";
  # echo -e "Package: ${package}";

  ## Identifying if package is already installed.
  available='';
  case "${installer}" in
      apt ) available="$(apt list --installed ${package} 2>/dev/null | egrep -w "^${package}.*")";
            status=$?; ;;
    snap* ) snap list ${package};
            result=$?; ;;
  esac;

  ## Configuring package status flag:
  [[ ${result} -eq 0 ]] && { result="present"; } || { result="absent"; }

  ## Evaluating APT Installed output
  if [[ $result == 'absent' ]]; then

          ## Package is not installed.
          echo -e "\n--------------------------------------------------------------------------------";
	        echo -e "Installing: ${result} = $(( counter++ )) -> $(( count_miss++ ))";
          echo -e "   Package: ${available}";
          echo -e "--------------------------------------------------------------------------------\n";
          echo -e "Warning: ${package} package is not installed! ";
          echo -e "${package}" >> ${missing};

          ## Constructing package's folder (container)
          xpath="${location}/missing/${package}";
          mkdir -p "${xpath}";

          ## Installing package depending on its manager (APT, SNAP)
          case "${installer}" in
              apt ) sudo apt  install ${package} --yes; ;;
            snap* ) sudo snap install ${package} ${installer/snap /}; ;;
          esac;

    else  ## Inspecting installed package.

          echo -e "\n--------------------------------------------------------------------------------";
          echo -e " Installed: ${result} = $(( counter++ )) -> $(( count_inst++ ))";
          echo -e "   Package: ${available}";
          echo -e "--------------------------------------------------------------------------------\n";
      	  echo -e "${package}" >> ${installed};

          ## Constructing package's folder (container)
          xpath="${location}/installed";
      	  mkdir -p "${xpath}";

          ## Upgrading package only if it's already installed.
          sudo apt-get --only-upgrade install ${package} --yes 2>/dev/null ;
          ## | tee "${xpath}/${package}.upgrade";

          declare -a apropos=();
          if [[ $( apropos ${package} 2>/dev/null | wc -l ) -eq 0 ]]; then
                  block_apropos='';
            else  for record in $(
                    apropos --exact ${package} 2>/dev/null | sed -e "s|\('\)\{1,\}|\'|g" -e 's|\("\)\{1,\}||g' 
                  ); do apropos+=("\"${record}\"@");
                  done;
                  ## Removing multiple spacing in a single entry.
                  [[ ${#apropos[@]} -eq 1 ]] && {
                        apropos="$(
                        echo -e "${apropos[@]}" | sed -e 's|\([[:blank:]]\)\{1,\}| |g'
                      )"
                    }
                  block_apropos="$(
                      echo -e ${apropos[@]} | sed -e 's|@$||' -e 's|@|,|g' 
                    )";
          fi;

          declare -a listing=();
          for record in $(
              apt list ${package} 2>/dev/null | egrep -v "^Listing....*$" \
                                  | sed -e "s|\('\)\{1,\}|\'|g" -e 's|\("\)\{1,\}||g'
            ); do listing+=("\"${record}\"@");
          done;

          ## Inspecting package based on its installer (APT, SNAP)
          case "${installer}" in

              apt ) declare -a headers=();
                    headers+=("^APT-Manual-Installed: ");
                    headers+=("^APT-Sources: ");
                    headers+=("^Breaks: ");
                    headers+=("^Build-Essential: ");
                    headers+=("^Built-Using: ");
                    headers+=("^Conflicts: ");
                    headers+=("^Depends: ");
                    headers+=("^Download-Size: ");
                    headers+=("^Enhances: ");
                    headers+=("^Essential: ");
                    headers+=("^Homepage: ");
                    headers+=("^Installed-Size: ");
                    headers+=("^Origin: ");
                    headers+=("^Original-Maintainer: ");
                    headers+=("^Package: ");
                    headers+=("^Pre-Depends: ");
                    headers+=("^Priority: ");
                    headers+=("^Provides: ");
                    headers+=("^Recommends: ");
                    headers+=("^Replaces: ");
                    headers+=("^Section: ");
                    headers+=("^Source: ");
                    headers+=("^Suggests: ");
                    headers+=("^Task: ");
                    headers+=("^Version: ");
                    headers+=("^X-Cargo-Built-Using: ");
                    packages="$(
                        for line in $( apt show ${package} 2>/dev/null ); do
                          [[ ${line} =~ "Description: " ]] && { break; } || { echo ${line}; };
                        done \
                        | sed -e 's|"||g' \
                        | egrep "$(echo -n ${headers[@]} | tr ' ' '|')" \
                        | egrep -v "^Maintainer: |^Bugs: " \
                        | sed \
                              -e 's|^\(APT-Manual-Installed\)\(: \)\(.*\)$| "\1"\2"\3" |g' \
                              -e 's|^\(APT-Sources\)\(: \)\(.*\)$| "\1"\2"\3" |g' \
                              -e 's|^\(Breaks\)\(: \)\(.*\)$| "\1"\2[ "\3" ]|g' \
                              -e 's|^\(Build-Essential\)\(: \)\(.*\)$| "\1"\2"\3" |g' \
                              -e 's|^\(Built-Using\)\(: \)\(.*\)$| "\1"\2[ "\3" ]|g' \
                              -e 's|^\(Conflicts\)\(: \)\(.*\)$| "\1"\2[ "\3" ]|g' \
                              -e 's|^\(Depends\)\(: \)\(.*\)$| "\1"\2[ "\3" ]|g' \
                              -e 's|^\(Download-Size\)\(: \)\(.*\)$| "\1"\2"\3" |g' \
                              -e 's|^\(Enhances\)\(: \)\(.*\)$| "\1"\2[ "\3" ]|g' \
                              -e 's|^\(Essential\)\(: \)\(.*\)$| "\1"\2"\3" |g' \
                              -e 's|^\(Homepage\)\(: \)\(.*\)$| "\1"\2"\3" |g' \
                              -e 's|^\(Installed-Size\)\(: \)\(.*\)$| "\1"\2"\3" |g' \
                              -e 's|^\(Origin\)\(: \)\(.*\)$| "\1"\2"\3" |g' \
                              -e 's|^\(Original-Maintainer\)\(: \)\(.*\)$| "\1"\2"\3" |g' \
                              -e 's|^\(Package\)\(: \)\(.*\)$|* "\1"\2"\3" |g' \
                              -e 's|^\(Pre-Depends\)\(: \)\(.*\)$| "\1"\2[ "\3" ]|g' \
                              -e 's|^\(Priority\)\(: \)\(.*\)$| "\1"\2"\3" |g' \
                              -e 's|^\(Provides\)\(: \)\(.*\)$| "\1"\2[ "\3" ]|g' \
                              -e 's|^\(Recommends\)\(: \)\(.*\)$| "\1"\2[ "\3" ]|g' \
                              -e 's|^\(Replaces\)\(: \)\(.*\)$| "\1"\2[ "\3" ]|g' \
                              -e 's|^\(Section\)\(: \)\(.*\)$| "\1"\2"\3" |g' \
                              -e 's|^\(Source\)\(: \)\(.*\)$| "\1"\2"\3" |g' \
                              -e 's|^\(Suggests\)\(: \)\(.*\)$| "\1"\2[ "\3" ]|g' \
                              -e 's|^\(Task\)\(: \)\(.*\)$| "\1"\2[ "\3" ]|g' \
                              -e 's|^\(Version\)\(: \)\(.*\)$| "\1"\2"\3" |g' \
                              -e 's|^\(X-Cargo-Built-Using\)\(: \)\(.*\)$| "\1"\2[ "\3" ]|g' \
                              -e 's|, |", "|g' \
                        | tr '\n' ',' | tr '*' '\n' \
                        | sort -n \
                        | tr '\n' '*' \
                        | sed -e 's|" ,\* "Package": "|" }, { "Package": "|g' \
                              -e 's|* "Package": |{ "Package": |' \
                              -e 's|^\(.*"\)\( ,\*\)$|\1|' \
                        | sed -e 's|^\(.*\)$|\1, "Apropos": [ '${block_apropos}' ]|' \
                        | sed -e 's|^\(.*\)$|\1, "Listing": [ '$(
                                echo -e ${listing[@]} | sed -e 's|@$||' -e 's|@|,|g'
                              )' ]|' \
                        | sed -e 's|^\(.*\)$|\1 }|'
                      )"; \
                    ## Processing and formatting the collected output into a JSON file.
                    echo -e;
                    echo -e "${packages}" | python -m json.tool | tee "${xpath}/${package}.json";
                    ;;

            snap* ) snap info ${package} | tee "${xpath}/${package}.info";
                    ;;

          esac;

  fi;

done;

## Exporting Installed Packages JSON file.
find ${location} -type f -name '*.json' | xargs -I {} cat {} | jq -s > $(pwd)/packages.json;

## Exporting Installed Packages (name, version) ino LIST file.
jq '.[] | "\(.Package) -> \(.Version)"' --raw-output $(pwd)/packages.json > $(pwd)/packages.list;

echo -e "\nDone.\n";

IFS="${oIFS}";
