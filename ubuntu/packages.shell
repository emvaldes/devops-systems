#!/usr/bin/env bash

## Objective:
## This first-release is to test the script's capabilities to identify if a
## package is installed or not. All these packages were manually installed.
## After this initial test, the target Virtual Machine will be reset to its
## baseline and the script will start installing all these packages.

## Notes: These are target (pending) tools with custom installations
## [configuration]:   pulumi
## [cloud tools]:     aws-iam-authenticator, awscli, saml2aws
## [hashicorp]:       boundary, consul, nomad, packer, terraform, vagrant, vault, waypoint

function packages_ubuntu () {
    local oIFS="${IFS}";
    for xitem in "${@}"; do
      IFS='='; set `echo -e "${xitem}" | sed -e '1s|^\(-\)\{1,\}||'`
      [[ ${1#*\--} = "pkgs-list" ]] && {
          declare -a pkgs_listing=($( echo -e ${2} | tr ',' '\n' ));
        };
      [[ ${1#*\--} = "log-file" ]] && local log_filename="${2}";
      [[ ${1#*\--} = "json-file" ]] && local json_filename="${2}";
      [[ ${1#*\--} = "report-file" ]] && local report_filename="${2}";
      [[ ${1#*\--} = "install" ]] && local install_packages='true';
      [[ ${1#*\--} = "import" ]] && local import_filename="${2}";
    done; IFS="${oIFS}";
    local oIFS="${IFS}"; IFS=$'\n';
    echo -e;
    timestamp="$(date +"%y%m%d%H%M%S")";
    dateset="${timestamp:0:6}";
    timeset="${timestamp:6:6}";
    ## Loading Modules (dependencies):
    declare -a modules=(
        export2json.shell
      );
    for module in ${modules[@]}; do
      if [[ -e $(pwd)/${module} ]]; then
              echo -e "Loading: '${module}' module!\n ";
              source $(pwd)/${module};
        else  echo -e "\nWarning: Module '${module}' is not found! \n";
              return 99;
      fi;
    done;
    ## Script configuration
    local script_path=$( dirname ${0} );
    ## echo -e "Script Path: ${script_path}";
    local script_name=$( basename ${0%\.*} );
    ## echo -e "Script Name: ${script_name}";
    local script_type=$( basename ${0##*\.} );
    ## echo -e "Script Type: ${script_type}";
    ## Define custom-parameter(s)
    if [[ ${#pkgs_listing} -eq 0 ]]; then
            local pkgs_listing='packages.list';
            ## Loading Packages Listing
            echo -e "Loading: '${pkgs_listing}' Default Packages List!\n ";
            source "${script_path}/${pkgs_listing}";
      else  echo -e "Loading: Custom Packages List!\n ";
            declare -a packages=( ${pkgs_listing[@]} );
            for package in ${packages[@]}; do echo -e "${package}"; done;
    fi;
    [[ ${#log_filename} -eq 0 ]] && {
        log_filename='packages.log';
        echo -e "Using: '${log_filename}' default Log file! ";
      };
    [[ ${#json_filename} -eq 0 ]] && {
        json_filename='packages.json';
        echo -e "Using: '${json_filename}' default JSON file! ";
      };
    [[ ${#report_filename} -eq 0 ]] && {
        report_filename='packages.report';
        echo -e "Using: '${report_filename}' default Report file! ";
      };
    if [[ ${install_packages} == 'true' ]]; then
            echo -e "\nInstalling: Marked Packages! ";
      else  install_packages='false';
    fi;
    if [[ ${#import_filename} -gt 0 ]]; then
            echo -e "\nImporting: '${import_filename}' custom file! ";
            import_report='true';
      else  import_report='false';
    fi;
    ## Script Execution Log-file
    local logfile="${script_path}/${log_filename}";
    cat /dev/null > "${logfile}";
    ## Aggregated & Exported JSON-file
    local jsonfile="${script_path}/${json_filename}";
    cat /dev/null > "${jsonfile}";
    ## Installed Packages Report-file
    local reportfile="${script_path}/${report_filename}";
    cat /dev/null > "${reportfile}";
    local sandbox='/tmp';
    local reports="${sandbox}/$(
        lsb_release -d \
        | sed -e 's|\([[:blank:]]*\)||g' -e 's|Description:||' \
        | tr '[[:upper:]]' '[[:lower:]]'
      )";
    ## Configuring Package Instation Reports path
    local location="${reports}/${dateset}/${timeset}/packages";
    ## Constructing target location
    mkdir -p ${location};
    ## Identifying the Installed-Packages report file
    local missing="${location}/missing.list";
    cat /dev/null > "${missing}"
    ## Default DPKG Log-file
    local dpkg_logfile='/var/log/dpkg.log';
    ## Defining iteration counters.
    local counter=1;
    local count_miss=1;
    local count_inst=1;
    ## Processing Listed Packages:
    for xitem in ${packages[@]}; do
      # if [[ ${import_report} == 'true' ]]; then
      #         echo -e "Processing APT Show Configuration report...";
      #         return 10;
      #   else  echo -e "Processing default workflow...";
      # fi;
      ## Options: apt, snap
      local installer=;
      local package=;
      if [[ ${xitem} =~ ':' ]]; then
              declare -a request=($( echo -e "${xitem}" | tr ':' '\n' ));
              package="${request[0]}";
              ## Removes first elemnent in array
              request=("${request[@]:1}");
              installer="${request[0]}";
        else  installer='apt';
	            package="${xitem}";
              request='';
      fi;
      ## Constructing package's folder (container)
      local xpath="${location}/present/${installer}";
      mkdir -p "${xpath}";
      ## Identifying if package is already installed.
      local status=;
      case "${installer}" in
         apt ) package_status="$(
                   apt list --installed ${package} 2>/dev/null \
                   | egrep -v "Listing... Done" | egrep -w "^${package}.*"
                 )";
               status=$?; ;;
        snap ) package_status="$(
                  snap list ${package} | egrep -w "^${package}.*"
                )";
               status=$?; ;;
      esac;
      local result=;
      [[ ${status} -eq 0 ]] && { result="present"; } || { result="absent"; }
      ## Skipping Processing blocks
      local skip_report='false';
      ## Evaluating APT Installed output
      if [[ $result == 'absent' ]]; then
              ## Package is not installed.
              echo -e "\n--------------------------------------------------------------------------------";
              echo -e "Installing: ${result} = $(( counter++ )) -> $(( count_miss++ ))";
              echo -e "   Warning: ${package} package is not installed! ";
              echo -e "--------------------------------------------------------------------------------";
              echo -e "${package}" >> ${missing};
              ## Constructing package's folder (container)
              # absent_tools="${location}/absent/${installer}";
              # mkdir -p "${absent_tools}";
              # echo -e "${package_status}" > "${absent_tools}/${package}.marked";
              if [[ ${install_packages} == 'true' ]]; then
                ## Constructing package's folder (container)
                installed_tools="${location}/installed/${installer}";
                mkdir -p "${installed_tools}";
                ## Installing package depending on its manager (APT, SNAP)
                status=;
                case "${installer}" in
                   apt ) sudo apt  install ${package} --yes \
                              | tee "${installed_tools}/${package}.log";
                         status=$?; ;;
                  snap ) sudo snap install ${package} ${installer/snap /} \
                              | tee "${installed_tools}/${package}.log";
                         status=$?; ;;
                esac;
                result=;
                [[ ${status} -eq 0 ]] && { result="present"; } || { result="absent"; }
              fi;
              ## Collecting Package Details (Specs)
              status=;
              case "${installer}" in
                 apt ) package_status="$(
                           apt list --installed ${package} 2>/dev/null \
                           | egrep -v "Listing... Done" | egrep -w "^${package}.*"
                         )";
                       status=$?; ;;
                snap ) package_status="$(
                          snap list ${package} | egrep -w "^${package}.*"
                        )";
                       status=$?; ;;
              esac;
              result=;
              [[ ${status} -eq 0 ]] && { result="present"; } || { result="absent"; }
        else  ## Processing Default Packages
              local default_packages="${reports}/default/${installer}";
              mkdir -p "${default_packages}";
              local already_exists="$(
                  find ${default_packages}/* \
                       -type f -name ${package} 2>/dev/null
                )";
              ## Processing Pre-Installed Packages
              [[ ${#already_exists} -gt 0 ]] && {
                  for xitem in ${preinstalled[@]}; do
                    [[ ${xitem} == ${package} ]] && {
                        xpath="${default_packages}/native";
                        mkdir -p "${xpath}" 2>/dev/null ;
                        skip_report='true'; break;
                      };
                  done;
                  ## Processing Post-Installed Packages
                  for xitem in ${postinstalled[@]}; do
                    [[ ${xitem} == ${package} ]] && {
                        xpath="${default_packages}/presets";
                        mkdir -p "${xpath}" 2>/dev/null ;
                        skip_report='true'; break;
                      };
                  done;
                };
              # ## Identifying if package is already installed
              # status=;
              # case "${installer}" in
              #    apt ) package_details="$(
              #              apt show ${package} 2>/dev/null | tee "${present_tools}/${package}.details"
              #            )";
              #          status=$?; ;;
              #   snap ) package_details="$(
              #              snap info ${package} | tee "${present_tools}/${package}.details"
              #            )";
              #          status=$?; ;;
              # esac;
              # result=;
              # [[ ${status} -eq 0 ]] && { result="present"; } || { result="absent"; }
              # [[ $result == 'present' ]] && mkdir -p "${default_packages}";
      fi;
      ## Upgrading package only if it's already installed.
      sudo apt-get --only-upgrade install ${package} --yes 2>/dev/null ;
      ## Determine if processing package-report
      if [[ ${skip_report} == 'false' ]]; then
        echo -e "\n--------------------------------------------------------------------------------";
        echo -e " Installed: ${result} = $(( counter++ )) -> $(( count_inst++ ))";
        echo -e "   Package: ${package_status}";
        echo -e "--------------------------------------------------------------------------------\n";
        # echo -e "${package}" >> ${installed};
        case "${installer}" in
           apt ) ## Processing APT-Installed Packages:
                 export2json --package="${package}" \
                             --location="${xpath}";
                 ;;
          snap ) snap info ${package} | tee "${xpath}/${package}.info";
                 ;;
        esac;
      fi;
    done;
    ## Exporting Installed Packages JSON file.
    find ${location} -type f -name '*.json' \
         | sort -n | xargs -I {} cat {} | jq -s | python -m json.tool > ${jsonfile};
    ## Exporting Installed Packages (name, version) ino LIST file.
    jq '.[] | "\(.Package) -> \(.Version)"' --raw-output ${jsonfile} > ${reportfile};
    echo -e "\nDone.\n";
    IFS="${oIFS}";
    return 0;
  }; alias packages-ubuntu='packages_ubuntu';

## packages_ubuntu --pkgs-list='jq,openssh-server,python-is-python3' \
packages_ubuntu --install \
                --log-file=packages.log \
                --json-file=packages.json \
                --report-file=packages.report \
| tee $(pwd)/packages.log;
